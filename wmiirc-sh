#!/bin/sh -f
# Configure wmii
#   vi:noet:ts=2:sw=2:ai

export EDITOR=vim

# Configuration Variables
#MODKEY=Mod1 #Alt
MODKEY=Mod4  #Win
UP=k
DOWN=j
LEFT=h
RIGHT=l

BACKGROUND_IMAGE="$HOME/lucy.jpg"
PDFPATH="$HOME:$HOME/pdf"

#When directly adjusting the mixer, which control to use:
VOLUME_MIXER_CONTROL=Master
#Accessed with Shift+FX86Volume...
VOLUME_MIXER_CONTROL2=PCM
#How much to adjust the volume by when a volume key is pressed:
VOLUME_DIFF=2

# Preferred applications:

WMII_TERM="x-terminal-emulator"

# for an application stored in the variable APP:
#  APP_ARGS may be created to specify the optional arguments
#  APP_TERMINAL if it exists and is not an empty string specifies that the application should run in a terminal

#Only cmus and mocp are supported to remote control with the MODKEY+z,x,c,v,b,-,+,<F8> and <F9> keys
MUSICPLAYER="cmus"
MUSICPLAYER_TERMINAL=1

MUSICPLAYER2="mocp"
MUSICPLAYER2_TERMINAL=1

WEBBROWSER="firefox"

QUICKWEBBROWSER="w3m"
QUICKWEBBROWSER_ARGS="http://www.google.com"
QUICKWEBBROWSER_TERMINAL=1

EMAILCLIENT="sup-mail"
EMAILCLIENT_TERMINAL=1

NEWSREADER="canto"
NEWSREADER_TERMINAL=1

TWITTERCLIENT="$HOME/mitter-0.4.3/mitter"

NETWORKMANAGER="wicd-curses"
NETWORKMANAGER_TERMINAL=1

# Preferred calculator program, will fall back and try some alternatives if it isn't found:
#CALCULATOR="mathomatic"
#CALCULATOR_TERMINAL=1

CALENDAR="wyrd"
CALENDAR_TERMINAL=1

# Colors tuples: "<text> <background> <border>"
WMII_NORMCOLORS='#888888 #222222 #333333'
WMII_FOCUSCOLORS='#ffffff #285577 #4c7899'

WMII_BACKGROUND='#333333'
WMII_FONT='fixed'

set -- $(echo $WMII_NORMCOLORS $WMII_FOCUSCOLORS)
WMII_MENU="dmenu -b -fn '$WMII_FONT' -nf '$1' -nb '$2' -sf '$4' -sb '$5'"
WMII_9MENU="wmii9menu -font '$WMII_FONT' -nf '$1' -nb '$2' -sf '$4' -sb '$5' -br '$6'"

# Column Rules
wmiir write /colrules <<!
/.*/ -> 58+42
!

# Tagging Rules
wmiir write /tagrules <<!
/XMMS.*/ -> ~
/MPlayer.*/ -> ~
/.*/ -> sel
/.*/ -> 1
!

# Status Bar Info
status()
{
	echo -n $(uptime | sed 's/.*://; s/,//g') '|' $(date)
}

# Event processing
#  Processed later by `wmiiloop' and evaled.
#  Duplicate the eval line and replace 'eval' with 'echo' for details.
eventstuff()
{
	cat <<'!'
	# Events
	Event Start
		case "$1" in
		wmiirc)
			exit;
		esac
	Event Key
		fn=$(echo "$@" | sed 's/[^a-zA-Z_0-9]/_/g')
		Key_$fn "$@"
	Event CreateTag
		echo "$WMII_NORMCOLORS" "$@" | wmiir create "/lbar/$@"
	Event DestroyTag
		wmiir remove "/lbar/$@"
	Event FocusTag
		wmiir xwrite "/lbar/$@" "$WMII_FOCUSCOLORS" "$@"
	Event UnfocusTag
		wmiir xwrite "/lbar/$@" "$WMII_NORMCOLORS" "$@"
	Event UrgentTag
		shift
		wmiir xwrite "/lbar/$@" "*$@"
	Event NotUrgentTag
		shift
		wmiir xwrite "/lbar/$@" "$@"
	Event LeftBarClick
		shift
		wmiir xwrite /ctl view "$@"
	# Actions
	Action quit
		wmiir xwrite /ctl quit
	Action exec
		wmiir xwrite /ctl exec "$@"
	Action rehash
		proglist $PATH >$progsfile
	Action status
		set +xv
		if wmiir remove /rbar/status 2>/dev/null; then
			sleep 2
		fi
		echo "$WMII_NORMCOLORS" | wmiir create /rbar/status
		while status | wmiir write /rbar/status; do
			sleep 1
		done
	Event ClientMouseDown
		client=$1; button=$2
		case "$button" in
		3)
			do=$(eval $WMII_9MENU -initial "${menulast:-SomeRandomName}" Nop Delete Fullscreen)
			case "$do" in
			Delete)
				wmiir xwrite /client/$client/ctl kill;;
			Fullscreen)
				wmiir xwrite /client/$client/ctl Fullscreen on;;
			esac
			menulast=${do:-"$menulast"}
		esac
	# Key Bindings
	Key $MODKEY-Control-t
		case $(wmiir read /keys | wc -l | tr -d ' \t\n') in
		0|1)
			echo -n $Keys | tr ' ' '\012' | wmiir write /keys
			wmiir xwrite /ctl grabmod $MODKEY;;
		*)
			wmiir xwrite /keys $MODKEY-Control-t
			wmiir xwrite /ctl grabmod Mod3;;
		esac
	Key $MODKEY-space
		wmiir xwrite /tag/sel/ctl select toggle
	Key $MODKEY-d
		wmiir xwrite /tag/sel/ctl colmode sel default
	Key $MODKEY-s
		wmiir xwrite /tag/sel/ctl colmode sel stack
	Key $MODKEY-m
		wmiir xwrite /tag/sel/ctl colmode sel max
	Key $MODKEY-a
		Action $(actionlist | eval $WMII_MENU) &
	Key $MODKEY-p
		sh -c "$(eval $WMII_MENU <$progsfile)" &
	Key $MODKEY-t
		wmiir xwrite /ctl "view $(tagsmenu)" &
	Key $MODKEY-Return
		eval $WMII_TERM &
	Key $MODKEY-Shift-space
		wmiir xwrite /tag/sel/ctl send sel toggle
	Key $MODKEY-f
		wmiir xwrite /client/sel/ctl Fullscreen toggle
	Key $MODKEY-Shift-c
		wmiir xwrite /client/sel/ctl kill
	Key $MODKEY-Shift-t
		wmiir xwrite "/client/$(wmiir read /client/sel/ctl)/tags" "$(tagsmenu)" &
	Key $MODKEY-$LEFT
		wmiir xwrite /tag/sel/ctl select left
	Key $MODKEY-$RIGHT
		wmiir xwrite /tag/sel/ctl select right
	Key $MODKEY-$DOWN
		wmiir xwrite /tag/sel/ctl select down
	Key $MODKEY-$UP
		wmiir xwrite /tag/sel/ctl select up
	Key $MODKEY-Shift-$LEFT
		wmiir xwrite /tag/sel/ctl send sel left
	Key $MODKEY-Shift-$RIGHT
		wmiir xwrite /tag/sel/ctl send sel right
	Key $MODKEY-Shift-$DOWN
		wmiir xwrite /tag/sel/ctl send sel down
	Key $MODKEY-Shift-$UP
		wmiir xwrite /tag/sel/ctl send sel up
	
	#DarkStarSword's custom keys:
	#Key XF86AudioLowerVolume
	#	volumeDown "$VOLUME_MIXER_CONTROL"
	#Key XF86AudioRaiseVolume
	#	volumeUp "$VOLUME_MIXER_CONTROL"
	#Key XF86AudioMute
	#	volumeMute "$VOLUME_MIXER_CONTROL"
	#Key Shift-XF86AudioLowerVolume
	#	volumeDown "$VOLUME_MIXER_CONTROL2"
	#Key Shift-XF86AudioRaiseVolume
	#	volumeUp "$VOLUME_MIXER_CONTROL2"
	#Key Shift-XF86AudioMute
	#	volumeMute "$VOLUME_MIXER_CONTROL2"
	#Key $MODKEY-XF86AudioLowerVolume
	#	musicPlayerCommand "Volume Down"
	#Key $MODKEY-XF86AudioRaiseVolume
	#	musicPlayerCommand "Volume Up"
	#Key $MODKEY-XF86AudioMute
	#	volumeMute "$VOLUME_MIXER_CONTROL"
	#Key XF86AudioPlay
	#	musicPlayerCommand "Play/Pause"
	#Key XF86AudioStop
	#	musicPlayerCommand "Stop"
	#Key XF86AudioPrev
	#	musicPlayerCommand "Previous Track"
	#Key XF86AudioNext
	#	musicPlayerCommand "Next Track"
	#Key XF86Eject
	#	displayStatus 'FIXME: smart eject'
	#	eject
	#Key XF86Calculator
	#	launchCalculator
	#Key XF86HomePage
	#	launchWebBrowser
	#Key XF86Mail
	#	launchEmailClient
	#Key XF86ScreenSaver
	#	lockScreen
	#Key XF86Display
	#	displayStatus 'XF86Display pressed'
	#Key XF86TouchpadToggle
	#	displayStatus 'FIXME: Toggle touchpad'
	Key $MODKEY-escape
		displayStatus Escape
	Key $MODKEY-grave
		toggleAutoLock
	Key $MODKEY-F1
		toggleAutoSuspend
	# Key $MODKEY-F2 unused
	Key $MODKEY-F3
		blankScreen
	Key $MODKEY-F4
		toggleScreenBlanking
	Key $MODKEY-F5
		toggleExternalDisplay
	Key $MODKEY-F6
		presentationMode
	# Key $MODKEY-F7 unused
	Key $MODKEY-F8
		# Same as -
		musicPlayerCommand "Volume Down"
	Key $MODKEY-F9
		# Same as +
		musicPlayerCommand "Volume Up"
	# Key $MODKEY-F10 unused
	# Key $MODKEY-F11 unused
	# Key $MODKEY-F12 unused
	# Key $MODKEY-0-9 are default wmii keys, defined below
	Key $MODKEY-minus
		# Same as F8
		musicPlayerCommand "Volume Down"
	Key $MODKEY-plus
		# Same as F9
		musicPlayerCommand "Volume Up"
	Key $MODKEY-q
		launchQuickWebBrowser
	Key $MODKEY-w
		launchWebBrowser
	Key $MODKEY-e
		launchEmailClient
	Key $MODKEY-r
		launchNewsReader
	# Key $MODKEY-t is a default wmii key, defined above
	Key $MODKEY-y
		launchPython
	Key $MODKEY-u
		launchMusicPlayer
	Key $MODKEY-i
		launchTwitterClient
	Key $MODKEY-o
		launch2ndMusicPlayer
	# Key $MODKEY-p is a default wmii key, defined above
	# Key $MODKEY-a is a default wmii key, defined above
	# Key $MODKEY-s is a default wmii key, defined above
	# Key $MODKEY-d is a default wmii key, defined above
	# Key $MODKEY-f is a default wmii key, defined above
	Key $MODKEY-g
		launchCalendar
	# Key $MODKEY-h is a default wmii key, defined above
	# Key $MODKEY-j is a default wmii key, defined above
	# Key $MODKEY-k is a default wmii key, defined above
	# Key $MODKEY-l is a default wmii key, defined above
	Key Mod1-Control-l
		lockScreen
	Key $MODKEY-z
		musicPlayerCommand "Previous Track"
	Key $MODKEY-x
		musicPlayerCommand "Play"
	Key $MODKEY-c
		musicPlayerCommand "Play/Pause"
	Key $MODKEY-v
		musicPlayerCommand "Stop"
	Key $MODKEY-b
		musicPlayerCommand "Next Track"
	Key $MODKEY-n
		launchNetworkManager
	# Key $MODKEY-m is a default wmii key, defined above
	Key $MODKEY-slash
		launchCalculator
	Key Caps_Lock
		updateCapsLockDisplay
	Key Num_Lock
		updateNumLockDisplay
!
	for i in 0 1 2 3 4 5 6 7 8 9; do
		cat <<!
	Key $MODKEY-$i
		wmiir xwrite /ctl view "$i"
	Key $MODKEY-Shift-$i
		wmiir xwrite /client/sel/tags "$i"
!
	done
}

# WM Configuration
wmiir write /ctl << EOF
font $WMII_FONT
focuscolors $WMII_FOCUSCOLORS
normcolors $WMII_NORMCOLORS
grabmod $MODKEY
border 1
EOF

export WMII_MENU WMII_9MENU WMII_FONT WMII_TERM
export WMII_FOCUSCOLORS WMII_SELCOLORS WMII_NORMCOLORS

# Feed events to `wmiiloop' for processing
eval "$(eventstuff | sed 's/^[	]//' | { . wmiiloop; })"

echo "$Keys" | tr ' ' '\n' | wmiir write /keys

# Functions
Action()
{
	action=$1; shift
	if [ -n "$action" ]; then
		Action_$action "$@" \
		|| conf_which $action "$@"
	fi
}

proglist()
{
	paths=$(echo "$@" | sed 'y/:/ /')
	ls -lL $paths 2>/dev/null \
		| awk '$1 ~ /^[^d].*x/ && NF > 2 { print $NF }' \
		| sort | uniq
}

pdflist()
{
	paths=$(echo "$@" | sed 'y/:/ /')
	ls -lLQ $paths 2>/dev/null \
		| awk -F\" '$1 ~ /^[^d][^ ]*r[^ ]* / && $2 ~ /\.[pP][dD][fF]$/ && NF > 2 { print $2 }' \
		| sort | uniq
}

# Misc
progsfile="$WMII_NS_DIR/.proglist"
pdfsfile="$WMII_NS_DIR/.pdflist"
Action status &
proglist $PATH >$progsfile &

# Setup Tag Bar
seltag="$(wmiir read /tag/sel/ctl 2>/dev/null)"
wmiir ls /lbar |
while read bar; do
	wmiir remove "/lbar/$bar"
done
wmiir ls /tag | sed -e 's|/||; /^sel$/d' |
while read tag; do
	if [ "X$tag" = "X$seltag" ]; then
		echo "$WMII_FOCUSCOLORS" "$tag" | wmiir create "/lbar/$tag" 
	else
		echo "$WMII_NORMCOLORS" "$tag" | wmiir create "/lbar/$tag"
	fi
done

# More functions
tagsmenu()
{
	wmiir ls /tag | sed 's|/||; /^sel$/d' | eval $WMII_MENU
}

actionlist()
{
	{	proglist $WMII_CONFPATH
		echo -n $Actions | tr ' ' '\012'
	} | sort | uniq
}

conf_which()
{
	which=$(which which)
	prog=$(PATH="$WMII_CONFPATH" $which $1); shift
	[ -n "$prog" ] && $prog "$@"
}

# DarkStarSword's Functions

displayStatus()
{
	MESSAGE="$1"
	DISPLAYTIME="$2"
	BARFILE="$3"
	(
	if [ ! "$DISPLAYTIME" ]; then
		DISPLAYTIME=5
	fi
	if [ ! "$BARFILE" ]; then
		BARFILE="aaa-"`date '+%s'`"-$RANDOM"
	else
		if [ -e "/tmp/wmii-${USER}-${DISPLAY}-status-${BARFILE}" ]; then
			kill $(cat "/tmp/wmii-${USER}-${DISPLAY}-status-${BARFILE}")
		fi
	fi
	wmiir remove /lbar/"$BARFILE" 2>/dev/null
	echo "$MESSAGE" | wmiir create /lbar/"$BARFILE"
	sleep "$DISPLAYTIME"
	wmiir remove /lbar/"$BARFILE"
	rm "/tmp/wmii-${USER}-${DISPLAY}-status-${BARFILE}"
	) &
	if [ "$BARFILE" ]; then
		echo `jobs -l %%|head -n 1|awk '{print $2}'` >> "/tmp/wmii-${USER}-${DISPLAY}-status-${BARFILE}"
	fi
}

lockScreen()
{
	if autoLockEnabled; then
		xautolock -locknow
	else
		enableAutoLock
		sleep 1
		xautolock -locknow
	fi
}
autoLockEnabled()
{
	if [ -e "/tmp/wmii-${USER}-${DISPLAY}-noautolock" ]; then
		return 1
	else
		return 0
	fi
}
killAutoLockNotifier()
{
	autoLockEnabled && return
	kill $(cat "/tmp/wmii-${USER}-${DISPLAY}-noautolock")
	rm "/tmp/wmii-${USER}-${DISPLAY}-noautolock"
}
enableAutoLock()
{
	killAutoLockNotifier
	xautolock -enable
	displayStatus "#ccff88 #334422 #333333 LOCK ENABLED" 1 lock
}
disableAutoLock()
{
	killAutoLockNotifier
	xautolock -disable
	(
	while true; do
		echo "#ffcc88 #443322 #333333 LOCK DISABLED" | wmiir create /lbar/lock && sleep 2
		echo "#ffff88 #664422 #333333 ++-8 DISABLED" | wmiir create /lbar/lock && sleep 2
	done
	) &
	echo `jobs -l %%|head -n 1|awk '{print $2}'` >> "/tmp/wmii-${USER}-${DISPLAY}-noautolock"
}
toggleAutoLock()
{
	if autoLockEnabled; then
		disableAutoLock
	else
		enableAutoLock
	fi
}

toggleAutoSuspend()
{
	if [ -e /tmp/noautosuspend ]; then
		rm /tmp/noautosuspend
		displayStatus "#ccff88 #334422 #333333 AUTO SUSPEND ENABLED" 5 suspend
	else
		touch /tmp/noautosuspend
		displayStatus "#ffcc88 #443322 #333333 AUTO SUSPEND DISABLED" 5 suspend
	fi
}

toggleScreenBlanking()
{
	# Screen will still blank if xautolock is triggered
	if ( xset q | grep 'DPMS is Enabled' ); then
		xset s off
		xset -dpms
		displayStatus "#88ccff #224433 #333333 SCREEN BLANKING DISABLED" 5 blank
	else
		xset s on
		xset +dpms
		displayStatus "#88ffcc #224433 #333333 SCREEN BLANKING ENABLED" 5 blank
	fi
}

blankScreen()
{
	# Slight delay to give the key a chance to release then blank screen
	sleep 0.1
	xset dpms force suspend
	# Delayed blank in case key release un-blanked screen later than expected
	sleep 0.5
	xset dpms force suspend
	# If the user had their hand on the key longer than that they can retry themselves,
	# otherwise this script risks becoming truly annoying
}

toggleExternalDisplay()
{
	Action display &
	return
	# Transition between display states:
	# State 1: Internal only 800x480
	# State 2: Dual cloned display  640x480
	# State 3: External only 800x600
	# If external not attached always transition to Internal only

	echo "Stand by..." | wmiir create /lbar/screen
	if xrandr | grep '^VGA connected [^(]*x'; then
		if xrandr | grep '^LVDS connected [^(]*x'; then
			# Dual display => External only
			xrandr --output LVDS --off --output VGA --mode 800x600
		else
			# Only external active => Internal only
			xrandr --output LVDS --mode 800x480 --output VGA --off
			xrandr --delmode VGA 640x480
		fi
	elif xrandr | grep '^LVDS connected [^(]*x'; then
		if xrandr | grep '^VGA connected'; then
			# Internal active, external attached but inactive => Dual display
			xrandr --addmode VGA 640x480
			xrandr --output LVDS --mode 640x480 --output VGA --mode 640x480
		else
			# Internal active, external not attached => Internal only
			xrandr --output LVDS --mode 800x480 --output VGA --off
			xrandr --delmode VGA 640x480
		fi
	else
		displayStatus "#ffcc88 #443322 #333333 UNRECOGNISED SCREEN CONFIGURATION" 5 screen
		return 1
	fi
	echo -n exec wmii | wmiir write /ctl
}

presentationMode()
{
	(
	pdflist $PDFPATH >$pdfsfile
	pdf=$(eval $WMII_MENU <$pdfsfile)

	#FIXME: Extra PDF paths don't work

	if [ -e "$pdf" ]; then
		Action display "$pdf" &
		return
		xautolock -disable
		xrandr --addmode VGA 640x480
		xrandr --output LVDS --mode 640x480 --output VGA --mode 640x480

		impressive -t Crossfade -T 100 "$pdf"

		xrandr --output LVDS --mode 800x480 --output VGA --off
		xrandr --delmode VGA 640x480
		xautolock -enable
	fi
	) &
}

updateCapsLockDisplay()
{
	if [ $((`xset q|awk '/LED/ {print $10}'|cut -c 8` % 2)) -eq 1 ]; then
		(
		echo "#ffcc88 #443322 #333333 C" | wmiir create /rbar/acaps
		# Work around for bug in wmii in which Keys are not received if caps lock is active and num lock is inactive
		while [ $((`xset q|awk '/LED/ {print $10}'|cut -c 8` % 2)) -eq 1 ]; do sleep 0.1;done
		wmiir remove /rbar/acaps
		) &
	else
		if [ ! $((`xset q|awk '/LED/ {print $10}'|cut -c 8` % 4 / 2)) -eq 1 ]; then
			# Notify me if the bug has been fixed
			displayStatus "#ffcc88 #443322 #333333 Debug: Received caps release notification while num lock was off" 2 caps
		fi
	fi
}
updateNumLockDisplay()
{
	if [ $((`xset q|awk '/LED/ {print $10}'|cut -c 8` % 4 / 2)) -eq 1 ]; then
		echo "#88ccff #223344 #333333 N" | wmiir create /rbar/anum
	else
		wmiir remove /rbar/anum
	fi
}

#These adjust the mixer directly, not a music player
volumeUp()
{
	CONTROL="$1"
	vol=`amixer sset "$CONTROL" ${VOLUME_DIFF}%+ | awk -F\[ '/%/ {print $2}'|head -n 1|awk -F\] '{print $1}'`
	displayStatus "$CONTROL mixer volume: $vol" 2 mixer
}
volumeDown()
{
	CONTROL="$1"
	vol=`amixer sset "$CONTROL" ${VOLUME_DIFF}%- | awk -F\[ '/%/ {print $2}'|head -n 1|awk -F\] '{print $1}'`
	displayStatus "$CONTROL mixer volume: $vol" 2 mixer
}
volumeMute()
{
	CONTROL="$1"
	mute=`amixer sset "$CONTROL" toggle | awk '/\[(on|off)\]/ {print $NF}'|head -n 1|tr -d '[]'`
	if [ -n "$mute" ]; then
		displayStatus "$CONTROL mixer: $mute" 2 mixer
	else
		displayStatus "$CONTROL mixer does not have a mute control" 2 mixer
	fi
}

musicPlayerCmusRunning()
{
	pidof cmus >/dev/null
}
musicPlayerCmusCommand()
{
	COMMAND="$1"
	case "$COMMAND" in
		'Previous Track') cmus-remote -r ;;
		'Play')           cmus-remote -p ;;
		'Play/Pause')     cmus-remote -u ;;
		'Stop')           cmus-remote -s ;;
		'Next Track')     cmus-remote -n ;;
		'Volume Down')    cmus-remote -v -${VOLUME_DIFF}% ;;
		'Volume Up')      cmus-remote -v +${VOLUME_DIFF}% ;;
		*) displayStatus "Command $COMMAND not recognised to control music with cmus" ;;
	esac
}
musicPlayerMocpRunning()
{
	pidof mocp >/dev/null
}
musicPlayerMocpCommand()
{
	COMMAND="$1"
	case "$COMMAND" in
		'Previous Track') mocp -r ;;
		'Play')           mocp -p ;;
		'Play/Pause')
			state=`mocp -i|grep ^State|awk '{print $2}'`
			if [ "$state" = "STOP" ]; then
				mocp -p #Play
			else
				mocp -G #Play/Pause
			fi ;;
		'Stop')           mocp -s ;;
		'Next Track')
			state=`mocp -i|grep ^State|awk '{print $2}'`
			if [ "$state" = "STOP" ]; then
				mocp -p #Play
			else
				mocp -f #Next
			fi ;;
		'Volume Down')    mocp -v -${VOLUME_DIFF} ;;
		'Volume Up')      mocp -v +${VOLUME_DIFF} ;;
		*) displayStatus "Command $COMMAND not recognised to control music with mocp" ;;
	esac
}
musicPlayerCommand()
{
	COMMAND="$1"
	displayStatus "music: $COMMAND" 1 musicplayer
	if musicPlayerCmusRunning; then
		musicPlayerCmusCommand "$COMMAND"
	elif musicPlayerMocpRunning; then
		musicPlayerMocpCommand "$COMMAND"
	else
		case "$COMMAND" in
			'Volume Down')    volumeDown "$VOLUME_MIXER_CONTROL" ;;
			'Volume Up')      volumeUp "$VOLUME_MIXER_CONTROL" ;;
			*) displayStatus "#ffcc88 #443322 #333333 No supported music player is running" 5 musicplayer ;;
		esac
	fi
}

launchProgram()
{
	PROGRAM="$1"
	ARGS="$2"
	TERMINAL="$3"
	FAILSILENT="$4"
	if which "$PROGRAM" >/dev/null; then
		displayStatus "Launching $PROGRAM..." 2
		if [ "$TERMINAL" ]; then
			$WMII_TERM -e "$PROGRAM" $ARGS &
		else
			"$PROGRAM" $ARGS &
		fi
		return 0
	elif [ -z "$FAILSILENT" ]; then
		displayStatus "#ffcc88 #443322 #333333 Cannot launch $PROGRAM: not found" 5 launchfail
		return 1
	fi
	return 1
}
launchProgramVar()
{
	# Get the name of the program to run with it's parameters from the passed in variable name
	VARIABLE=`eval "echo '\$'$1"`
	PROGRAM=`eval "echo ${VARIABLE}"`
	ARGS=`eval "echo ${VARIABLE}_ARGS"`
	TERMINAL=`eval "echo ${VARIABLE}_TERMINAL"`
	FAILSILENT="$2"
	[ -n "$PROGRAM" ] || return
	launchProgram "$PROGRAM" "$ARGS" "$TERMINAL" "$FAILSILENT"
	# WARN: Return value from launchProgram must be passed on
}

launchMusicPlayer()
{
	launchProgramVar MUSICPLAYER
}
launch2ndMusicPlayer()
{
	launchProgramVar MUSICPLAYER2
}
launchQuickWebBrowser()
{
	launchProgramVar QUICKWEBBROWSER
}
launchWebBrowser()
{
	launchProgramVar WEBBROWSER
}
launchEmailClient()
{
	launchProgramVar EMAILCLIENT
}
launchNewsReader()
{
	launchProgramVar NEWSREADER
}
launchTwitterClient()
{
	launchProgramVar TWITTERCLIENT
}
launchNetworkManager()
{
	launchProgramVar NETWORKMANAGER
}
launchCalculator()
{
	launchProgramVar CALCULATOR && return
	launchProgram "calc" "" "1" "1" && return
	launchProgram "mathomatic" "" "1" "1" && return
	launchProgram "ipython" "" "1" "1" && return
	launchProgram "python" "" "1" "1" && return
	displayStatus "#ffcc88 #443322 #333333 No suitable calculator program found!" 5 launchfail
}
launchCalendar()
{
	launchProgramVar CALENDAR
}
launchPython()
{
	launchProgram "ipython" "" "1" && return
	launchProgram "python" "" "1" && return
	displayStatus "#ffcc88 #443322 #333333 Python interpreter not found!" 5 launchfail
}

#Set the background
if which feh >/dev/null && [ -f "$BACKGROUND_IMAGE" ]; then
	feh --bg-scale "$BACKGROUND_IMAGE" &
else
	xsetroot -solid "$WMII_BACKGROUND" &
fi

#Start the screen auto locker
#FIXME: Add lock warning
xautolock -time 1 -locker "$HOME/.wmii-3.5/lock" -corners 000- &
if autoLockEnabled; then
	enableAutoLock
else
	disableAutoLock
fi

#Start battery monitor
Action battery &

# Stop any running instances of wmiirc
echo Start wmiirc | wmiir write /event || exit 1

wmiir read /event |
while read event; do
	set -- $event
	event=$1; shift
	Event_$event $@
done 2>/dev/null
